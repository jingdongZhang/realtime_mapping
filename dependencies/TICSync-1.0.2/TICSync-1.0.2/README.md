TICSync - Knowing when things happened
======================================

A Clock Synchronization Library  
Copyright 2012 Isis Innovation Limited  
University of Oxford

Alastair Harrison  
<arh@robots.ox.ac.uk>

Mobile Robotics Group  
Dept. Engineering Science  
University of Oxford

License and use
===============

Please see the LICENSE file for details of the licenses covering various parts
of this software.

If you use this software for your research, please cite the following paper in
your publications:

    @INPROCEEDINGS { HarrisonTICSync,
        ADDRESS = { Shanghai, China },
        AUTHOR = { Alastair Harrison and Paul Newman },
        BOOKTITLE = { Proc. {IEEE} International Conference on
                      Robotics and Automation (ICRA2011) },
        MONTH = { May },
        TITLE = { TICSync: Knowing When Things Happened },
        YEAR = { 2011 }
    }

Overview
========

TICSync is a library of C++ classes for rapidly synchronizing devices. More
specifically it is used for learning the mapping between clocks in different
devices.  It explicitly does not alter the clock on any machine, as that seems a
bit rude.

Its main features are:

-   Extremely efficient algorithm with constant time updates
-   Rapid filter convergence (tens of microseconds within a few seconds is
    possible
-   Small footprint
-   Core library is header-only and very portable
-   Simple interface

In its current state, TICSync is a little rough around the edges, and
particularly lacking in Doxygen comments.  It is however perfectly usable and
has shown its utility in a number of real-world scenarios requiring
high-precision clock synchronization.

We hope you like it!

Acknowledgements
================

-   Feb 2011: Paul Furgale, for his early testing of TICSync, and suggestions
    for fixing up the Windows build.
-   May 2012: Christoph Sprunk for fixes to the exceptions.

Installation
============

Please see the instructions in the 'INSTALL.md' file.

Example Programs
================

There are sample programs included with TICSync, to demonstrate the use of the
various filters and support classes.  They are:

-   TICSyncTimeServer  
    A time server that can be used with the pingClient, BasicTimeClient and
    SynchroClient sample programs.

-   BasicTimeClient  
    Shows how to query the Time Server for the current time.

-   pingClient  
    Queries the Time Server at a fixed rate and outputs the ping event time
    stamps in a three column text file.

-   SynchroClient  
    Shows how to use the SynchronizationClient class to perform automatic
    synchronization with the Time Server.

-   Int64TwoWaySync  
    Command line filter for ping data such as that produced by the pingClient.
    Allows off-line processing of ping traces.  Specialized for working with
    integer time stamp values (such as epoch microseconds).

-   TimestampCorrector  
    Command line filter for time stamps generated by an external device that
    cannot run a time server.

Using TICSync in your projects
==============================

If you're using CMake to build your project, simply use:

    find_package(TICSync REQUIRED)
    include_directories(${TICSync_INCLUDE_DIRS})
    
    ...
    
    target_link_libraries(<target-name> ... ${TICSync_LIBRARIES} ... )

You DO NOT need a FindTICSync.cmake script.  TICSync provides a suitable
TICSyncConfig.cmake file in both its build directory and the install directory.
It also adds itself to the CMake project cache, so that other projects may pick
up its location automatically.

Organization of the source tree
===============================

As it stands, the TICSync library is split into two main parts:


Core
----
This is a header-only library of templated classes which implement the core
TICSync algorithms.  If you already have timestamps from a pair of devices then
you may use these classes directly.


TimeServices library
--------------------
This is a small library of helper classes, which set up socket-based
communication between a pair of computers, handle the gathering of time stamps,
and then learn the mapping between the clocks of the two computers.

There are sample programs demonstrating the different functions of both the Core
library and the TimeServices library.  These can be found within a 'samples'
subdirectory in each library.  There is also a top-level 'samples' directory
containing further useful sample programs.


Getting Started
===============

There are a number of different levels at which you can use the TICSync library.
We'll start with the highest level abstractions and work down.

Automatic Synchronization of two computers
------------------------------------------
The highest level abstraction available is the SynchronizationClient class,
which lives in the TimeServices library.  It connects to a time server on
another computer and pings it regularly in a background thread.  The two-way
delay measurements from each ping are fed into a SwitchingTwoWayClockSync
object, which takes care of learning the mapping between clocks.

To see how this works, compile the TICSync sample programs on two different
machines connected by a network.  If you don't have two machines to hand, just
run the sample programs on a single machine.


*Step 1:* Run the time server on MachineA, listening on port 5000

    MachineA:> cd /path/to/TICSync/build/
    MachineA:> ./bin/TICSyncTimeServer -p 5000

*Step 2:* Run the SynchroClient example on MachineB, and point it at the Time
Server on MachineA

    MachineB:> cd /path/to/TICSync/build/
    MachineB:> ./bin/SynchroClient -a MachineA -p 5000

This will produce output every second, showing the current time at MachineA and
the estimated mapping between the clocks of the two machines.

*NOTE: The TimeServer is capable of serving multiple clients simultaneously*

### Using the SynchronizationClient in your own code

Taking a closer look at the code in SynchroClientMain.cpp, we see that using the
SynchronizationClient is very lightweight, with the important lines being:

    #include "TICSync/SynchronizationClient.h"
    
    ...
    
    std::string serverAddress("tcp://192.168.0.25:5000");
    TICSync::SynchronizationClient timeClient(serverAddress);
    
    // Start background pinging thread
    timeClient.start();
    
    ...
    
    // Find out the time at the server
    Poco::Timestamp serverTime = timeClient.serverTimeNow();
    
    ...
    
    // Stop background pinging thread
    timeClient.stop();

### Other useful methods of the SynchronizationClient
Other useful methods of the SynchronizationClient class are `toServerTime()`
and `toClientTime()`, which take a time stamp local to the client or server
respectively, and map it to the equivalent time on the other device.

### Caveats
On Windows machines, Poco::Timestamp does not make use of the High Performance
timers.  Therefore the available resolution is limited to around 10ms.  If you
wish to achieve higher resolution then you will need to produce your own ping
sequences and feed them into the lower level classes in TICSync Core.  This is
described in the next section.

Manual synchronization of two computers
---------------------------------------
In some cases it is not convenient to use the higher level abstractions in the
TimeServices library, such as if you wish to avoid the dependency on Poco and
ZMQ. You can generate ping data yourself (perhaps off the back of your own comms
layer) and feed it into the lower level classes contained within the TICSync
Core library.

To use these classes you need to generate ping data yourself, at a rate suitable
for the application and accuracy required.  The data from each ping should
consist of three separate time stamps:

-   Time at which the client requested the time (measured by the client clock)
-   Time at which the server processed the request (measured by the server
    clock)
-   Time at which the client received the response (measured by the client
    clock)

We will refer to these as the request, server and receipt times respectively.
The units and datatype may be whatever you like, as long as the following
conditions are met:

-   The data type must be the same for both client and server time stamps
-   The data type must support negative values
-   The data type must support the usual arithmetic operators (+, -, \*, /)
-   The units do NOT need to be the same for client and server
-   The clocks are monotonically non-decreasing functions

For example, you might wish to represent time in integer microseconds, in which
case a 64-bit int datatype would be appropriate.  Alternatively, to represent
time in floating point seconds to microsecond resolution a 64-bit double
datatype would work.  It is also possible to use less conventional units, such
as a message counter on a device that streams output with no explicit time
stamps.

### LinearTwoWayClockSync
The basic component for learning the mapping between the client and server
clocks is the LinearTwoWayClockSync class.  It is appropriate for cases where
the two clocks are running at different frequencies, but the relative frequency
does not change (ie zero drift).  For consumer grade computer equipment, this is
a reasonable assumption to make for periods of tens of minutes in
temperature-stable environments.  For longer periods, or for clocks with
pronounced non-zero drift characteristics, you should use the
SwitchingTwoWayClockSync class, which is described shortly.

    #include "TICSync/LinearTwoWayClockSync.h"
    
    ...
    
    // Note that we template on the time stamp datatype 'int64_t',
    // which might in this case represent epoch time in microseconds
    TICSync::LinearTwoWayClockSync<int64_t> clockMapper;
    
    while (1)
    {
        ...
       
        // Obtain ping timestamps
        // requestTime, serverTime and receiptTime  
    
        ...   
    
        // Push the ping timestamps into the filter
        clockMapper.update(requestTime, serverTime, receiptTime);   
    
        ...
    
        // Convert a client time stamp 'eventA_ClientTime' to a server time stamp
        int64_t eventA_ServerTime =
            clockMapper.clientTimeToServerTime(eventA_ClientTime);
            
        ...
    
        // Convert a server time stamp 'eventB_ServerTime' to a client time stamp
        int64_t eventB_ClientTime = 
            clockMapper.serverTimeToClientTime(eventB_ServerTime);
    }
    
    ...

### SwitchingTwoWayClockSync
In cases where clock drift is significant, the SwitchingTwoWayClockSync class is
almost a direct drop in replacement for the LinearTwoWayClockSync class above.
In fact it maintains two overlapping LinearTwoWayClockSync filter objects, which
are never allowed to grow beyond a certain size.  When the 'active' filter has
grown too long, it is reset and swapped with the 'inactive' filter.  In this
way, the nonlinear mapping between the two clocks is represented with a series
of short(ish) overlapping piecewise linear sections.

The only difference in interface when compared to the LinearTwoWayClockSync
class is that the constructor requires a parameter specifying the switching
period, in server clock units.


    #include "TICSync/SwitchingTwoWayClockSync.h"
    
    ...
    
    // Note that we template on the time stamp datatype 'double', which might in
    // this case represent epoch time in floating point seconds.
    // This filter switches every 30 seconds, once the currently active filter
    // has reached a length of 60 seconds.
    TICSync::SwitchingTwoWayClockSync<double> clockMapper(30.0);
    
    ...


Correcting Time Stamps from an external device
----------------------------------------------

TICSync can help with correcting time stamps from external devices such as IMUs
and laser scanners, on which we cannot run a time server.  It does this using an
implementation of the one-way estimator described by [Moon, Skelly and
Towsley][1].

Let us consider the case of a SICK LMS-151 laser scanner, which is an
ethernet-enabled device that communicates using TCP packets.  The 151 has an
internal clock running at close to real-time, and it publishes time stamps with
each scan that it emits.  The internal clock is not accurate enough for the time
stamps to be used directly.  The usual solution therefore is to grab a local
time stamp on the logging computer whenever a new scan message is received.
These time stamps are consistent with the local clock, but suffer from noise
induced by the variable transport delay inherent with TCP comms.

The LinearOneWayClockSync class allows us to learn the mapping between the clock
on the laser and the clock on the logging PC.  We can then take the laser time
stamps as our source, and simply map them to logging PC timestamps, thus
avoiding the variable transport delay noise.  Note however that the output time
stamps will always be subject to a steady state offset, equal to the (unknown)
minimum network delay.

The LinearOneWayClockSync class takes as input the low-noise but unrealistic
time stamps produced by an external device, and the realistic but noisy time
stamps produced by the logging PC.  It outputs filtered logging PC time stamps
that better represent the true time that data was gathered.

*NOTE: Some devices, such as the SICK LMS200 do not explicitly output a time
stamp field.  However, since they output scans at a constant rate, the scan
counter value that they publish (once unwrapped) can actually be used by TICSync
as a 'surrogate' clock value.*


    #include "TICSync/LinearOneWayClockSync.h"
    
    ...
    
    // Note that we template on the time stamp datatype 'int64_t', which
    // might represent epoch microseconds for the logging PC, and a sample
    // counter for an LMS200 laser device.
    TICSync::LinearOneWayClockSync<int64_t> timestampCorrector();
    
    ...
    
    while (1)
    {
        ...
        
        // Read next message from laser and get a local timestamp
        ReadFromLaser(&lasermsg)
        int64_t localTime = TimeNow();
        int64_t deviceTime = GetLaserTimestamp(lasermsg);
    
        ...
    
        // Filter a pair of time stamps attached to a single laser scan
        int64_t correctedLocalTime =
            timestampCorrector.filterTimestamp(deviceTime, localTime);
    
        ...
    }


### Caveats
The LinearOneWayClockSync class deals only with clocks having a linear (zero
drift) relationship.  As with the two-way filters, there is also a
'SwitchingOneWayClockSync' class which is able to track clock drift over longer
periods. See the description of the SwitchingTwoWayClockSync class above.

*****

[1]: http://dx.doi.org/10.1109/INFCOM.1999.749287 "S. Moon, P. Skelly and D. Towsley, Estimation and Removal of Clock Skew from Network Delay Measurements., In proceedings of IEEE INFOCOM 99, New York, NY"
