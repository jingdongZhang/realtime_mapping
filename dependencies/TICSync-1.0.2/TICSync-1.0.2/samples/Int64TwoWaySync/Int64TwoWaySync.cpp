/* 
 * copyright {
 * TICSync - A Clock Synchronization Library
 * Copyright 2012 Isis Innovation Limited
 * University of Oxford
 * 
 * Authors: Alastair Harrison
 *          arh@robots.ox.ac.uk
 *
 * See included LICENSE file for license details
 * }
 */

#include <iostream>
#include <fstream>
#include <memory>
#include <iomanip>
#include <string>
#include <sstream>
#include <cstdlib>
#include <vector>
#include "TICSync/LinearTwoWayClockSync.h"
#include "TICSync/TwoWayTimestamps.h"
#include "Poco/Timestamp.h"


using namespace TICSync;
using namespace std;
using Poco::Timestamp;


typedef TwoWayTimestamps<Poco::Timestamp> TSTriple;


void stripPath(std::string& filename)
{
  std::string::size_type n = filename.find_last_of(std::string("/\\"));
  if (n != std::string::npos)
  {
    filename = filename.substr(n + 1);
  }
}

void displayHelp(int argc, const char** argv, bool bAdvanced)
{
  // Remove path from binary name
  string filename = string(argv[0]);
  stripPath(filename);

  cout << "Usage: ";
  cout << filename << " OPTIONS INFILE [-o OUTFILE]\n";
  cout << "Learns mapping between clocks on two separate devices.  Specifically\n";
  cout << "designed to work with integer clock values.\n";
  cout << "\n";
  cout << "-a, --advanced-help        Give more details about file formats\n";
  cout << "-d, --delimiter            Column delimiting character.\n";
//  cout << "-e, --extra-output         Includes extra columns in output data.\n";
  cout << "-h, --help                 Prints this usage message.\n";
  cout << "-o, --output <outfile>     Specifies file to receive program output.\n";
  cout << "\n";
  cout << "With no INFILE, or when INFILE is -, read from standard input.\n";
  cout << "If -o option is not specified, output is written to standard output.\n";
  cout << "Input is not buffered, so " << filename << " can be used as a real-time filter.\n";
  cout << "\n\n";
  cout << "Example Usage\n";
  cout << "=============\n";
  cout << filename << " - -d ' ' -o myoutputfile\n";
  cout << "  Reads from standard in, expecting spaces as delimiters, and outputs to myoutputfile.\n";
  cout << "\n\n";

  if (!bAdvanced)
    return;

  cout << "General Description\n";
  cout << "===================\n";
  cout << "This program is designed for learning the mapping between the clocks of two computers,\n";
  cout << "based on two-way timing data gathered by a separate process, such as pingClient.\n";
  cout << "If you wish to have the data gathering handled automatically, check out the\n";
  cout << "TimeServer and SynchronizationClient example programs.\n";
  cout << "\n\n";
  cout << "Input and output format\n";
  cout << "=======================\n";
  cout << "The input data should consist of three columns, delimited by spaces (override this with -d). ";
  cout << "The first column contains the request timestamps generated by the local clock.  The ";
  cout << "second column contains the server timestamps of the same event.  The third column contains ";
  cout << "the client receipt timestamps.\n";
  cout << "THE TIMESTAMPS SHOULD ALL BE INTEGERS\n";
  cout << "\n";
  cout << "The output data consists of the same first three columns as the input, but with two ";
  cout << "extra columns containing the skew and offset between the two clocks.\n";
//  cout << "\n";
//  cout << "Optionally, if the -e switch is specified, then extra columns will appear in the ";
//  cout << "output.  These are:\n";
//  cout << "  - The relative frequency of the two clocks.\n";
//  cout << "\n";

  cout.flush();
}

// A structure to hold the program options
struct ProgOpts
{
  ProgOpts() : bHelp(false), bAdvancedHelp(false), cDelim(' '), bExtraOutput(false), infile("-"), outfile("-") {};

  bool bHelp;
  bool bAdvancedHelp;
  char cDelim;
  bool bExtraOutput;
  string infile;
  string outfile;
};


void parseArgs(int argc, const char** argv, ProgOpts& opts)
{
  bool bHaveInfile = false;

  int i=1;
  while (i < argc)
  {
    string token(argv[i]);
    if (token.compare("-a")==0 || token.compare("--advanced-help")==0)
    {
      opts.bHelp = true; opts.bAdvancedHelp = true;
      break;
    }
    if (token.compare("-h")==0 || token.compare("--help")==0)
    {
      opts.bHelp = true;
      ++i; continue;
    }
//    if (token.compare("-e")==0 || token.compare("--extra-output")==0)
//    {
//      opts.bExtraOutput = true;
//      ++i; continue;
//    }
    if (token.compare("-o")==0 || token.compare("--output")==0)
    {
      if (++i == argc)
      {
        opts.bHelp = true;
        break;
      }
      opts.outfile = string(argv[i]);
      ++i; continue;
    }
    if (token.compare("-d")==0 || token.compare("--delimiter")==0)
    {
      if (++i == argc)
      {
        opts.bHelp = true;
        break;
      }
      string delim(argv[i]);
      if (delim.length() != 1)
      {
        opts.bHelp = true;
        break;
      }
      opts.cDelim = *(delim.data());
      ++i; continue;
    }
    if (token.compare("-")==0)
    {
      if (token.length() > 1)
      {
        opts.bHelp = true;
        break;
      }
      opts.infile = "-";
      ++i; continue;
    }
    if (bHaveInfile)
    {
      opts.bHelp = true;
      break;
    }
    opts.infile = std::string(argv[i]);
    bHaveInfile = true;
    ++i;
  }
}


void tokenize(const std::string& str, const std::string& delimiters, std::vector<std::string>& tokens)
{
  // skip delimiters at beginning.
  string::size_type lastPos = str.find_first_not_of(delimiters, 0);

  // find first "non-delimiter".
  string::size_type pos = str.find_first_of(delimiters, lastPos);

  while (string::npos != pos || string::npos != lastPos)
  {
    // found a token, add it to the vector.
    tokens.push_back(str.substr(lastPos, pos - lastPos));

    // skip delimiters
    lastPos = str.find_first_not_of(delimiters, pos);

    // find next "non-delimiter"
    pos = str.find_first_of(delimiters, lastPos);
  }
}


bool parseLine(std::istream& is, TSTriple& ts, const ProgOpts& opts)
{
  std::string line;

  if (std::getline(is, line).eof())
    return false;

  std::vector<std::string> tokens;
  tokenize(line, std::string(&opts.cDelim, 1), tokens);

  if (tokens.size() < 2)
    return false;

  std::string sRQ(tokens.at(0));
  ts.requestTime = strtol(sRQ.c_str(), 0, 0);

  std::string sTX(tokens.at(1));
  ts.serverTime = strtol(sTX.c_str(), 0, 0);

  std::string sRX(tokens.at(2));
  ts.receiptTime = strtol(sRX.c_str(), 0, 0);

  return true;
}


void doWork(std::istream& is, std::ostream& os, const ProgOpts& opts)
{
  TICSync::LinearTwoWayClockSync<Timestamp::TimeVal> filt;

  os.setf(std::ios::fixed);
  os.precision(15);

  // Read data from input stream and output processed data
  while (!is.eof())
  {
    TSTriple ts;

    if (!parseLine(is, ts, opts))
      return;

    // Push values through the clock sync filter
    filt.update(ts.requestTime.epochMicroseconds(), ts.serverTime.epochMicroseconds(), ts.receiptTime.epochMicroseconds());

    os << ts.requestTime.epochMicroseconds() << opts.cDelim;
    os << ts.serverTime.epochMicroseconds()  << opts.cDelim;
    os << ts.receiptTime.epochMicroseconds() << opts.cDelim;

    if (filt.isStable())
    {
      os << filt.skew() << opts.cDelim;
      os << filt.mostRecentOffset();
    }
    else
    {
      os << 0.0 << opts.cDelim;
      os << 0L;
    }


//    if (opts.bExtraOutput)
//    {
//      os << opts.cDelim << "some value";
//    }

    os << "\n";
  }
  os.flush();
}


int main(int argc, const char** argv)
{
  ProgOpts opts;
  parseArgs(argc, argv, opts);

  if (opts.bHelp)
  {
    displayHelp(argc, argv, opts.bAdvancedHelp);
    exit(0);
  }

  // Set up an input stream pointer, to be attached to stdin or a file
  std::istream* pInput;
  std::ifstream fin;
  if (opts.infile.compare("-") == 0)
  {
    // Read input from stdin
    pInput = &std::cin;
  }
  else
  {
    // Read input from a file
    fin.open(opts.infile.c_str(), std::ios::in);
    if (!fin)
    {
      std::cerr << "Can't open file: '" << opts.infile << "' for input\n";
      exit(1);
    }
    pInput = &fin;
  }

  // Set up an output stream pointer, to be attached to stdout or a file
  std::ostream* pOutput;
  std::ofstream fout;
  if (opts.outfile.compare("-") == 0)
  {
    // Write outupt to stdout
    pOutput = &std::cout;
  }
  else
  {
    // Write output to a file
    fout.open(opts.outfile.c_str(), std::ios::out);
    if (!fout)
    {
      std::cerr << "Can't open file: '" << opts.outfile << "' for output\n";
      exit(1);
    }
    pOutput = &fout;
  }


  doWork(*pInput, *pOutput, opts);


  return 0;
}

