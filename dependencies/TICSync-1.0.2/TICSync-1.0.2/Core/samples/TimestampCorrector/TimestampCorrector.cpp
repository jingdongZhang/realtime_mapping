/* 
 * copyright {
 * TICSync - A Clock Synchronization Library
 * Copyright 2012 Isis Innovation Limited
 * University of Oxford
 * 
 * Authors: Alastair Harrison
 *          arh@robots.ox.ac.uk
 *
 * See included LICENSE file for license details
 * }
 */

#include <iostream>
#include <fstream>
#include <memory>
#include <iomanip>
#include <string>
#include <sstream>
#include <cstdlib>
#include <vector>
#include <TICSync/LinearOneWayClockSync.h>


using namespace TICSync;
using namespace std;


void stripPath(string& filename)
{
  string::size_type n = filename.find_last_of(string("/\\"));
  if (n != string::npos)
  {
    filename = filename.substr(n + 1);
  }
}

void displayHelp(int argc, const char** argv, bool bAdvanced)
{
  // Remove path from binary name
  string filename = string(argv[0]);
  stripPath(filename);

  cout << "Usage: ";
  cout << filename << " OPTIONS INFILE [-o OUTFILE]\n";
  cout << "Corrects noisy timestamps for events happening on a remote device.\n";
  cout << "\n";
  cout << "-a, --advanced-help        Give more details about file formats\n";
  cout << "-d, --delimiter            Column delimiting character.\n";
  cout << "-e, --extra-output         Includes extra columns in output data.\n";
  cout << "-h, --help                 Prints this usage message.\n";
  cout << "-o, --output <outfile>     Specifies file to receive program output.\n";
  cout << "\n";
  cout << "With no INFILE, or when INFILE is -, read from standard input.\n";
  cout << "If -o option is not specified, output is written to standard output.\n";
  cout << "Input is not buffered, so " << filename << " can be used as a real-time filter.\n";
  cout << "\n\n";
  cout << "Example Usage\n";
  cout << "=============\n";
  cout << filename << " - -d ' ' -o myoutputfile\n";
  cout << "  Reads from standard in, expecting spaces as delimiters, and outputs to myoutputfile.\n";
  cout << "\n\n";

  if (!bAdvanced)
    return;

  cout << "General Description\n";
  cout << "===================\n";
  cout << "This program is designed for correcting timestamps on data (or events) received ";
  cout << "over a comms channel with time varying latencies.\n";
  cout << "\n";
  cout << "Suppose a computer with its own internal clock is receiving data packets from a ";
  cout << "sensor over wireless ethernet, and timestamping on reception.  The timestamps will ";
  cout << "be in error by whatever the network latency was on that packet.  Even if the sensor ";
  cout << "itself is able to timestamp at source, it cannot be guaranteed (indeed it is most ";
  cout << "unlikely) that the sensor clock is running at the same frequency as the computer's ";
  cout << "clock.\n";
  cout << "\n";
  cout << "This program takes the noisy timestamps from the local clock, and the low noise but ";
  cout << "inconsistent timestamps from the remote device and processes them to produce low ";
  cout << "noise local timestamps.  Please note that even when the filter has converged, there ";
  cout << "must still be an unknown constant offset in the timestamps, equal to the minimum ";
  cout << "transmission delay.\n";
  cout << "\n\n";
  cout << "Input and output format\n";
  cout << "=======================\n";
  cout << "The input data should consist of two columns, delimited by spaces (override this with -d). ";
  cout << "The first column contains the receipt timestamps generated by the local clock.  The ";
  cout << "second column contains the device timestamps of the same event.  Note that these ";
  cout << "could simply be integer sample IDs, so long as the sample rate is guaranteed to be ";
  cout << "constant.\n";
  cout << "\n";
  cout << "The output data consists of the same first two columns as the input, but with a third ";
  cout << "column containing the corrected local timestamps.\n";
  cout << "\n";
  cout << "Optionally, if the -e switch is specified, then extra columns will appear in the ";
  cout << "output.  These are:\n";
  cout << "  - The relative frequency of the two clocks.\n";
  cout << "\n";

  cout.flush();
}

// A structure to hold the program options
struct ProgOpts
{
  ProgOpts() : bHelp(false), bAdvancedHelp(false), cDelim(' '), bExtraOutput(false), infile("-"), outfile("-") {};

  bool bHelp;
  bool bAdvancedHelp;
  char cDelim;
  bool bExtraOutput;
  string infile;
  string outfile;
};


void parseArgs(int argc, const char** argv, ProgOpts& opts)
{
  bool bHaveInfile = false;

  int i=1;
  while (i < argc)
  {
    string token(argv[i]);
    if (token.compare("-a")==0 || token.compare("--advanced-help")==0)
    {
      opts.bHelp = true; opts.bAdvancedHelp = true;
      break;
    }
    if (token.compare("-h")==0 || token.compare("--help")==0)
    {
      opts.bHelp = true;
      ++i; continue;
    }
    if (token.compare("-e")==0 || token.compare("--extra-output")==0)
    {
      opts.bExtraOutput = true;
      ++i; continue;
    }
    if (token.compare("-o")==0 || token.compare("--output")==0)
    {
      if (++i == argc)
      {
        opts.bHelp = true;
        break;
      }
      opts.outfile = string(argv[i]);
      ++i; continue;
    }
    if (token.compare("-d")==0 || token.compare("--delimiter")==0)
    {
      if (++i == argc)
      {
        opts.bHelp = true;
        break;
      }
      string delim(argv[i]);
      if (delim.length() != 1)
      {
        opts.bHelp = true;
        break;
      }
      opts.cDelim = *(delim.data());
      ++i; continue;
    }
    if (token.compare("-")==0)
    {
      if (token.length() > 1)
      {
        opts.bHelp = true;
        break;
      }
      opts.infile = "-";
      ++i; continue;
    }
    if (bHaveInfile)
    {
      opts.bHelp = true;
      break;
    }
    opts.infile = string(argv[i]);
    bHaveInfile = true;
    ++i;
  }
}


void tokenize(const std::string& str, const std::string& delimiters, std::vector<std::string>& tokens)
{
  // skip delimiters at beginning.
  string::size_type lastPos = str.find_first_not_of(delimiters, 0);

  // find first "non-delimiter".
  string::size_type pos = str.find_first_of(delimiters, lastPos);

  while (string::npos != pos || string::npos != lastPos)
  {
    // found a token, add it to the vector.
    tokens.push_back(str.substr(lastPos, pos - lastPos));

    // skip delimiters
    lastPos = str.find_first_not_of(delimiters, pos);

    // find next "non-delimiter"
    pos = str.find_first_of(delimiters, lastPos);
  }
}


bool parseLine(std::istream& is, double& localTime, double& devTime, const ProgOpts& opts)
{
  std::string line;

  if (std::getline(is, line).eof())
    return false;

  std::vector<std::string> tokens;
  tokenize(line, std::string(&opts.cDelim, 1), tokens);

  if (tokens.size() < 2)
    return false;

  std::string sLocal(tokens.at(0));

  int pos = sLocal.find_first_not_of(" \t", 0);
  localTime = strtod(sLocal.substr(pos).c_str(), 0);

  std::string sDev(tokens.at(1));
  pos = sDev.find_first_not_of("\t ", 0);
  devTime = strtod(sDev.substr(pos).c_str(), 0);

  return true;
}


void doWork(std::istream& is, std::ostream& os, const ProgOpts& opts)
{
  LinearOneWayClockSync<double> filt;

  os.setf(std::ios::fixed);
  os.precision(6);

  // Read data from input stream and output processed timestamps
  while (!is.eof())
  {
    double dfLocal = 0.0;
    double dfDev   = 0.0;

    if (!parseLine(is, dfLocal, dfDev, opts))
      return;

    // Push values through the magical timestamp filter
    double dfCorrected = filt.filterTimestamp(dfDev, dfLocal);

    os << dfLocal << opts.cDelim;
    os << dfDev << opts.cDelim;
    os << dfCorrected;

    if (opts.bExtraOutput)
    {
      os << opts.cDelim << filt.skew();
    }

    os << "\n";
  }
}


int main(int argc, const char** argv)
{
  ProgOpts opts;
  parseArgs(argc, argv, opts);

  if (opts.bHelp)
  {
    displayHelp(argc, argv, opts.bAdvancedHelp);
    exit(0);
  }

  // Set up an input stream pointer, to be attached to stdin or a file
  std::istream* pInput;
  std::ifstream fin;
  if (opts.infile.compare("-") == 0)
  {
    // Read input from stdin
    pInput = &std::cin;
  }
  else
  {
    // Read input from a file
    fin.open(opts.infile.c_str(), std::ios::in);
    if (!fin)
    {
      std::cerr << "Can't open file: '" << opts.infile << "' for input\n";
      exit(1);
    }
    pInput = &fin;
  }

  // Set up an output stream pointer, to be attached to stdout or a file
  std::ostream* pOutput;
  std::ofstream fout;
  if (opts.outfile.compare("-") == 0)
  {
    // Write outupt to stdout
    pOutput = &std::cout;
  }
  else
  {
    // Write output to a file
    fout.open(opts.outfile.c_str(), std::ios::out);
    if (!fout)
    {
      std::cerr << "Can't open file: '" << opts.outfile << "' for output\n";
      exit(1);
    }
    pOutput = &fout;
  }


  doWork(*pInput, *pOutput, opts);


  return 0;
}

